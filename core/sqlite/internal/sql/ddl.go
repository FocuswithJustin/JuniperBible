package sql

import (
	"fmt"
	"strings"

	"github.com/FocuswithJustin/JuniperBible/core/sqlite/internal/btree"
	"github.com/FocuswithJustin/JuniperBible/core/sqlite/internal/parser"
	"github.com/FocuswithJustin/JuniperBible/core/sqlite/internal/vdbe"
)

// Schema represents the database schema containing tables and indexes.
type Schema struct {
	Tables  map[string]*Table  // Table name -> Table definition
	Indexes map[string]*Index  // Index name -> Index definition
}

// NewSchema creates a new empty schema.
func NewSchema() *Schema {
	return &Schema{
		Tables:  make(map[string]*Table),
		Indexes: make(map[string]*Index),
	}
}

// GetTable returns a table by name.
func (s *Schema) GetTable(name string) *Table {
	return s.Tables[name]
}

// AddTable adds a table to the schema.
func (s *Schema) AddTable(table *Table) error {
	if _, exists := s.Tables[table.Name]; exists {
		return fmt.Errorf("table %q already exists", table.Name)
	}
	s.Tables[table.Name] = table
	return nil
}

// RemoveTable removes a table from the schema.
func (s *Schema) RemoveTable(name string) error {
	if _, exists := s.Tables[name]; !exists {
		return fmt.Errorf("table %q does not exist", name)
	}
	delete(s.Tables, name)
	return nil
}

// AddIndex adds an index to the schema.
func (s *Schema) AddIndex(index *Index) error {
	if _, exists := s.Indexes[index.Name]; exists {
		return fmt.Errorf("index %q already exists", index.Name)
	}
	s.Indexes[index.Name] = index
	return nil
}

// RemoveIndex removes an index from the schema.
func (s *Schema) RemoveIndex(name string) error {
	if _, exists := s.Indexes[name]; !exists {
		return fmt.Errorf("index %q does not exist", name)
	}
	delete(s.Indexes, name)
	return nil
}

// Index represents a database index.
type Index struct {
	Name     string   // Index name
	Table    string   // Table name
	Columns  []string // Indexed column names
	Unique   bool     // True for UNIQUE indexes
	RootPage int      // Root page in database file
}

// CompileCreateTable generates VDBE bytecode for CREATE TABLE.
func CompileCreateTable(stmt *parser.CreateTableStmt, schema *Schema, bt *btree.Btree) (*vdbe.VDBE, error) {
	// Check if table already exists
	if existingTable := schema.GetTable(stmt.Name); existingTable != nil {
		if stmt.IfNotExists {
			// IF NOT EXISTS - just return success without error
			v := vdbe.New()
			v.AddOp(vdbe.OpHalt, 0, 0, 0)
			return v, nil
		}
		return nil, fmt.Errorf("table %q already exists", stmt.Name)
	}

	// Validate table name
	if stmt.Name == "" {
		return nil, fmt.Errorf("table name cannot be empty")
	}
	if strings.ToLower(stmt.Name) == "sqlite_master" || strings.ToLower(stmt.Name) == "sqlite_schema" {
		return nil, fmt.Errorf("table name %q is reserved", stmt.Name)
	}

	// Create Table from AST
	table, err := createTableFromAST(stmt, bt)
	if err != nil {
		return nil, fmt.Errorf("failed to create table definition: %w", err)
	}

	// Add table to schema
	if err := schema.AddTable(table); err != nil {
		return nil, err
	}

	// Generate VDBE bytecode
	v := vdbe.New()
	v.SetReadOnly(false)

	// Initialize the program
	v.AddOp(vdbe.OpInit, 0, 0, 0)

	// Allocate a new root page for the table
	// In a real implementation, this would interact with the pager
	// For now, we'll use a simple page allocation scheme
	rootPage := allocateRootPage(bt)
	table.RootPage = int(rootPage)

	// Create the CREATE TABLE SQL statement text for sqlite_master
	createSQL := generateCreateTableSQL(stmt)

	// Register allocation:
	// R[1] = "table"
	// R[2] = table name
	// R[3] = table name (same as name)
	// R[4] = root page number
	// R[5] = CREATE TABLE SQL text
	v.AllocMemory(6) // Allocate 6 registers (0-5)

	// Load values into registers
	v.AddOpWithP4Str(vdbe.OpString, 0, 1, 0, "table")                    // R[1] = "table"
	v.AddOpWithP4Str(vdbe.OpString, 0, 2, 0, table.Name)                 // R[2] = table name
	v.AddOpWithP4Str(vdbe.OpString, 0, 3, 0, table.Name)                 // R[3] = table name
	v.AddOpWithP4Int(vdbe.OpInteger, int(rootPage), 4, 0, int32(rootPage)) // R[4] = rootpage
	v.AddOpWithP4Str(vdbe.OpString, 0, 5, 0, createSQL)                  // R[5] = SQL

	// Open cursor 0 on sqlite_master for writing
	// sqlite_master is always at root page 1
	v.AllocCursors(1)
	v.AddOp(vdbe.OpOpenWrite, 0, 1, 0) // Cursor 0, root page 1

	// Create a record from registers 1-5 and insert into sqlite_master
	v.AddOp(vdbe.OpMakeRecord, 1, 5, 6) // Make record from R[1..5] into R[6]
	v.AddOp(vdbe.OpInsert, 0, 6, 0)     // Insert R[6] into cursor 0

	// Close cursor
	v.AddOp(vdbe.OpClose, 0, 0, 0)

	// Halt with success
	v.AddOp(vdbe.OpHalt, 0, 0, 0)

	return v, nil
}

// CompileDropTable generates VDBE bytecode for DROP TABLE.
func CompileDropTable(stmt *parser.DropTableStmt, schema *Schema, bt *btree.Btree) (*vdbe.VDBE, error) {
	// Check if table exists
	table := schema.GetTable(stmt.Name)
	if table == nil {
		if stmt.IfExists {
			// IF EXISTS - just return success without error
			v := vdbe.New()
			v.AddOp(vdbe.OpHalt, 0, 0, 0)
			return v, nil
		}
		return nil, fmt.Errorf("table %q does not exist", stmt.Name)
	}

	// Validate table name
	if strings.ToLower(stmt.Name) == "sqlite_master" || strings.ToLower(stmt.Name) == "sqlite_schema" {
		return nil, fmt.Errorf("cannot drop system table %q", stmt.Name)
	}

	// Generate VDBE bytecode
	v := vdbe.New()
	v.SetReadOnly(false)

	// Initialize the program
	v.AddOp(vdbe.OpInit, 0, 0, 0)

	// Allocate registers and cursors
	v.AllocMemory(3) // R[0..2]
	v.AllocCursors(2) // Cursor 0 for sqlite_master, cursor 1 for the table

	// Open cursor 1 on the table to be dropped
	v.AddOp(vdbe.OpOpenWrite, 1, table.RootPage, 0)

	// Clear all data from the table
	// This is a simplified approach - real SQLite would iterate and delete
	v.AddOp(vdbe.OpClose, 1, 0, 0)

	// Free all pages used by the table
	// In a real implementation, this would call btree page freeing functions
	// For now, we just note that pages starting from table.RootPage should be freed

	// Open cursor 0 on sqlite_master for writing
	v.AddOp(vdbe.OpOpenWrite, 0, 1, 0) // Cursor 0, root page 1

	// Find and delete the row in sqlite_master for this table
	// R[1] = table name to search for
	v.AddOpWithP4Str(vdbe.OpString, 0, 1, 0, table.Name)

	// Scan sqlite_master to find the row with matching name
	// This is simplified - real implementation would use index or rowid
	addrLoop := v.AddOp(vdbe.OpRewind, 0, 0, 0) // Start at beginning
	addrNext := v.NumOps()

	// Read column 1 (name) from sqlite_master
	v.AddOp(vdbe.OpColumn, 0, 1, 2) // Read column 1 into R[2]

	// Compare R[2] with R[1]
	addrDelete := v.AddOp(vdbe.OpEq, 1, 0, 2) // If R[1] == R[2], jump to delete

	// Move to next row
	v.AddOp(vdbe.OpNext, 0, addrNext, 0)
	v.AddOp(vdbe.OpGoto, 0, addrLoop+1, 0) // Jump past loop if no more rows

	// Delete the current row
	addrDeleteOp := v.NumOps()
	v.AddOp(vdbe.OpDelete, 0, 0, 0)

	// Patch the jump address
	if instr, _ := v.GetInstruction(addrDelete); instr != nil {
		instr.P2 = addrDeleteOp
	}
	if instr, _ := v.GetInstruction(addrLoop); instr != nil {
		instr.P2 = v.NumOps() // Jump past loop when rewind is done
	}

	// Close cursor
	v.AddOp(vdbe.OpClose, 0, 0, 0)

	// Remove from schema cache
	schema.RemoveTable(stmt.Name)

	// Halt with success
	v.AddOp(vdbe.OpHalt, 0, 0, 0)

	return v, nil
}

// CompileCreateIndex generates VDBE bytecode for CREATE INDEX.
func CompileCreateIndex(stmt *parser.CreateIndexStmt, schema *Schema, bt *btree.Btree) (*vdbe.VDBE, error) {
	// Check if index already exists
	if _, exists := schema.Indexes[stmt.Name]; exists {
		if stmt.IfNotExists {
			// IF NOT EXISTS - just return success without error
			v := vdbe.New()
			v.AddOp(vdbe.OpHalt, 0, 0, 0)
			return v, nil
		}
		return nil, fmt.Errorf("index %q already exists", stmt.Name)
	}

	// Validate table exists
	table := schema.GetTable(stmt.Table)
	if table == nil {
		return nil, fmt.Errorf("table %q does not exist", stmt.Table)
	}

	// Validate columns exist in the table
	columnNames := make([]string, len(stmt.Columns))
	for i, col := range stmt.Columns {
		columnNames[i] = col.Column
		found := false
		for _, tableCol := range table.Columns {
			if tableCol.Name == col.Column {
				found = true
				break
			}
		}
		if !found {
			return nil, fmt.Errorf("column %q does not exist in table %q", col.Column, stmt.Table)
		}
	}

	// Allocate root page for the index
	rootPage := allocateRootPage(bt)

	// Create index definition
	index := &Index{
		Name:     stmt.Name,
		Table:    stmt.Table,
		Columns:  columnNames,
		Unique:   stmt.Unique,
		RootPage: int(rootPage),
	}

	// Add index to schema
	if err := schema.AddIndex(index); err != nil {
		return nil, err
	}

	// Generate VDBE bytecode
	v := vdbe.New()
	v.SetReadOnly(false)

	// Initialize the program
	v.AddOp(vdbe.OpInit, 0, 0, 0)

	// Create the CREATE INDEX SQL statement text for sqlite_master
	createSQL := generateCreateIndexSQL(stmt)

	// Register allocation for sqlite_master insert
	v.AllocMemory(6)

	// Load values into registers
	v.AddOpWithP4Str(vdbe.OpString, 0, 1, 0, "index")        // R[1] = "index"
	v.AddOpWithP4Str(vdbe.OpString, 0, 2, 0, index.Name)     // R[2] = index name
	v.AddOpWithP4Str(vdbe.OpString, 0, 3, 0, index.Table)    // R[3] = table name
	v.AddOpWithP4Int(vdbe.OpInteger, int(rootPage), 4, 0, int32(rootPage)) // R[4] = rootpage
	v.AddOpWithP4Str(vdbe.OpString, 0, 5, 0, createSQL)      // R[5] = SQL

	// Open cursor on sqlite_master
	v.AllocCursors(2)
	v.AddOp(vdbe.OpOpenWrite, 0, 1, 0) // Cursor 0 for sqlite_master

	// Insert into sqlite_master
	v.AddOp(vdbe.OpMakeRecord, 1, 5, 6) // Make record from R[1..5] into R[6]
	v.AddOp(vdbe.OpInsert, 0, 6, 0)     // Insert R[6] into cursor 0

	// Now populate the index by scanning the table
	// Open cursor 1 on the table
	v.AddOp(vdbe.OpOpenRead, 1, table.RootPage, 0)

	// Open cursor for the new index (cursor 2, but we only allocated 2, so reuse or allocate more)
	v.AllocCursors(3)
	v.AddOp(vdbe.OpOpenWrite, 2, int(rootPage), 0)

	// Scan the table and insert into index
	addrRewind := v.AddOp(vdbe.OpRewind, 1, 0, 0)
	addrLoop := v.NumOps()

	// For each row, extract the indexed columns and insert into index
	// This is simplified - real implementation would handle multiple columns properly
	for i, colName := range columnNames {
		// Find column index in table
		colIdx := -1
		for j, col := range table.Columns {
			if col.Name == colName {
				colIdx = j
				break
			}
		}
		if colIdx >= 0 {
			// Read column into register
			v.AddOp(vdbe.OpColumn, 1, colIdx, 10+i)
		}
	}

	// Get rowid
	v.AddOp(vdbe.OpRowid, 1, 7, 0)

	// Make index record and insert
	v.AddOp(vdbe.OpMakeRecord, 10, len(columnNames)+1, 8)
	v.AddOp(vdbe.OpIdxInsert, 2, 8, 0)

	// Next row
	v.AddOp(vdbe.OpNext, 1, addrLoop, 0)

	// Patch rewind jump
	if instr, _ := v.GetInstruction(addrRewind); instr != nil {
		instr.P2 = v.NumOps()
	}

	// Close cursors
	v.AddOp(vdbe.OpClose, 0, 0, 0)
	v.AddOp(vdbe.OpClose, 1, 0, 0)
	v.AddOp(vdbe.OpClose, 2, 0, 0)

	// Halt
	v.AddOp(vdbe.OpHalt, 0, 0, 0)

	return v, nil
}

// createTableFromAST creates a Table definition from the parser AST.
func createTableFromAST(stmt *parser.CreateTableStmt, bt *btree.Btree) (*Table, error) {
	if len(stmt.Columns) == 0 {
		return nil, fmt.Errorf("table must have at least one column")
	}

	table := &Table{
		Name:        stmt.Name,
		NumColumns:  len(stmt.Columns),
		Columns:     make([]Column, len(stmt.Columns)),
		RootPage:    0, // Will be set later
		PrimaryKey:  -1,
		RowidColumn: -1,
	}

	// Process columns
	for i, colDef := range stmt.Columns {
		col := Column{
			Name:     colDef.Name,
			DeclType: colDef.Type,
			Affinity: typeNameToAffinity(colDef.Type),
		}

		// Process constraints
		for _, constraint := range colDef.Constraints {
			switch constraint.Type {
			case parser.ConstraintPrimaryKey:
				col.PrimaryKey = true
				table.PrimaryKey = i
				if constraint.PrimaryKey != nil && constraint.PrimaryKey.Autoincrement {
					table.RowidColumn = i
				}
			case parser.ConstraintNotNull:
				col.NotNull = true
			case parser.ConstraintDefault:
				// Store default value expression
				col.DefaultValue = convertExpr(constraint.Default)
			}
		}

		table.Columns[i] = col
	}

	return table, nil
}

// typeNameToAffinity converts a type name to type affinity.
func typeNameToAffinity(typeName string) Affinity {
	if typeName == "" {
		return SQLITE_AFF_BLOB
	}

	upper := strings.ToUpper(typeName)

	// INTEGER affinity
	if strings.Contains(upper, "INT") {
		return SQLITE_AFF_INTEGER
	}

	// TEXT affinity
	if strings.Contains(upper, "CHAR") || strings.Contains(upper, "CLOB") || strings.Contains(upper, "TEXT") {
		return SQLITE_AFF_TEXT
	}

	// BLOB affinity
	if strings.Contains(upper, "BLOB") {
		return SQLITE_AFF_BLOB
	}

	// REAL affinity
	if strings.Contains(upper, "REAL") || strings.Contains(upper, "FLOA") || strings.Contains(upper, "DOUB") {
		return SQLITE_AFF_REAL
	}

	// NUMERIC affinity (default for everything else)
	return SQLITE_AFF_NUMERIC
}

// convertExpr converts parser.Expression to sql.Expr.
// This is a simplified conversion for default values.
func convertExpr(expr parser.Expression) *Expr {
	if expr == nil {
		return nil
	}

	// Handle literals
	if lit, ok := expr.(*parser.LiteralExpr); ok {
		result := &Expr{}
		switch lit.Type {
		case parser.LiteralInteger:
			result.Op = TK_INTEGER
			result.StringValue = lit.Value
		case parser.LiteralFloat:
			result.Op = TK_FLOAT
			result.StringValue = lit.Value
		case parser.LiteralString:
			result.Op = TK_STRING
			result.StringValue = lit.Value
		case parser.LiteralNull:
			result.Op = TK_NULL
		}
		return result
	}

	// For other expression types, create a placeholder
	return &Expr{
		Op: TK_NULL,
	}
}

// allocateRootPage allocates a new root page in the btree.
// This is a simplified implementation.
func allocateRootPage(bt *btree.Btree) uint32 {
	// In a real implementation, this would interact with the pager
	// to allocate a new page. For now, we'll use the number of pages + 2
	// (page 1 is sqlite_master, so start from 2)
	return uint32(len(bt.Pages) + 2)
}

// generateCreateTableSQL generates the CREATE TABLE SQL text from the AST.
func generateCreateTableSQL(stmt *parser.CreateTableStmt) string {
	var sql strings.Builder
	sql.WriteString("CREATE TABLE ")
	if stmt.IfNotExists {
		sql.WriteString("IF NOT EXISTS ")
	}
	sql.WriteString(stmt.Name)
	sql.WriteString(" (")

	for i, col := range stmt.Columns {
		if i > 0 {
			sql.WriteString(", ")
		}
		sql.WriteString(col.Name)
		if col.Type != "" {
			sql.WriteString(" ")
			sql.WriteString(col.Type)
		}

		// Add constraints
		for _, constraint := range col.Constraints {
			switch constraint.Type {
			case parser.ConstraintPrimaryKey:
				sql.WriteString(" PRIMARY KEY")
				if constraint.PrimaryKey != nil && constraint.PrimaryKey.Autoincrement {
					sql.WriteString(" AUTOINCREMENT")
				}
			case parser.ConstraintNotNull:
				sql.WriteString(" NOT NULL")
			case parser.ConstraintUnique:
				sql.WriteString(" UNIQUE")
			case parser.ConstraintDefault:
				sql.WriteString(" DEFAULT ")
				sql.WriteString(constraint.Default.String())
			}
		}
	}

	sql.WriteString(")")
	return sql.String()
}

// generateCreateIndexSQL generates the CREATE INDEX SQL text from the AST.
func generateCreateIndexSQL(stmt *parser.CreateIndexStmt) string {
	var sql strings.Builder
	sql.WriteString("CREATE ")
	if stmt.Unique {
		sql.WriteString("UNIQUE ")
	}
	sql.WriteString("INDEX ")
	if stmt.IfNotExists {
		sql.WriteString("IF NOT EXISTS ")
	}
	sql.WriteString(stmt.Name)
	sql.WriteString(" ON ")
	sql.WriteString(stmt.Table)
	sql.WriteString(" (")

	for i, col := range stmt.Columns {
		if i > 0 {
			sql.WriteString(", ")
		}
		sql.WriteString(col.Column)
		switch col.Order {
		case parser.SortAsc:
			sql.WriteString(" ASC")
		case parser.SortDesc:
			sql.WriteString(" DESC")
		}
	}

	sql.WriteString(")")
	return sql.String()
}
