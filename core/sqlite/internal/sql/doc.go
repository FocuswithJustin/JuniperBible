// Package sql provides SQL statement compilation for a pure Go SQLite database engine.
//
// This package is a pure Go implementation based on SQLite source code.
// SQLite is in the public domain: https://sqlite.org/copyright.html
//
// This package implements the compilation of INSERT, UPDATE, and DELETE statements
// into VDBE (Virtual Database Engine) bytecode, along with the SQLite record format
// encoding/decoding functionality.
//
// # Architecture
//
// The package is organized into several components:
//
//   - record.go: SQLite record format encoding and decoding
//   - insert.go: INSERT statement compilation
//   - update.go: UPDATE statement compilation
//   - delete.go: DELETE statement compilation
//
// # Record Format
//
// SQLite uses a specific binary format for storing records. Each record consists of:
//
//   1. Header: A varint containing the header size, followed by serial type codes
//   2. Body: The actual column values in sequence
//
// Serial type codes indicate the storage class and size of each value:
//
//   - 0: NULL
//   - 1: 8-bit signed integer
//   - 2: 16-bit big-endian signed integer
//   - 3: 24-bit big-endian signed integer
//   - 4: 32-bit big-endian signed integer
//   - 5: 48-bit big-endian signed integer
//   - 6: 64-bit big-endian signed integer
//   - 7: IEEE 754 float64 (big-endian)
//   - 8: Integer constant 0 (no data stored)
//   - 9: Integer constant 1 (no data stored)
//   - N>=12 (even): BLOB of (N-12)/2 bytes
//   - N>=13 (odd): TEXT of (N-13)/2 bytes
//
// # Example: Record Creation
//
//	values := []Value{
//	    IntValue(1),
//	    TextValue("Alice"),
//	    FloatValue(98.5),
//	}
//	record, err := MakeRecord(values)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// # Example: Record Parsing
//
//	parsed, err := ParseRecord(record)
//	if err != nil {
//	    log.Fatal(err)
//	}
//	for i, val := range parsed.Values {
//	    fmt.Printf("Column %d: %+v\n", i, val)
//	}
//
// # VDBE Bytecode
//
// SQL statements are compiled into a sequence of VDBE instructions. Each instruction
// has an opcode and up to 5 parameters (P1-P5) plus an optional comment.
//
// # Example: INSERT Compilation
//
//	stmt := NewInsertStmt("users", []string{"id", "name"}, [][]Value{
//	    {IntValue(1), TextValue("Alice")},
//	    {IntValue(2), TextValue("Bob")},
//	})
//
//	prog, err := CompileInsert(stmt, tableRoot)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	// Print disassembly
//	fmt.Println(prog.Disassemble())
//
// The generated bytecode for a simple INSERT looks like:
//
//	0    Init         0    7    0              0    Initialize program
//	1    OpenWrite    0    100  0              0    Open table users for writing
//	2    NewRowid     0    0    0              0    Generate new rowid for row 0
//	3    Integer      1    1    0              0    Load integer 1
//	4    String       0    2    0    'Alice'   0    Load string 'Alice'
//	5    MakeRecord   1    2    3              0    Make record from 2 columns
//	6    Insert       0    3    0              0    Insert row 0
//	7    Close        0    0    0              0    Close table users
//	8    Halt         0    0    0              0    End program
//
// # Example: UPDATE Compilation
//
//	where := NewWhereClause(
//	    NewBinaryExpression(
//	        NewColumnExpression("id"),
//	        "=",
//	        NewLiteralExpression(IntValue(1)),
//	    ),
//	)
//
//	stmt := NewUpdateStmt(
//	    "users",
//	    []string{"name"},
//	    []Value{TextValue("Alice Updated")},
//	    where,
//	)
//
//	prog, err := CompileUpdate(stmt, tableRoot, numColumns)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// # Example: DELETE Compilation
//
//	stmt := NewDeleteStmt("users", where)
//
//	prog, err := CompileDelete(stmt, tableRoot)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// # DELETE Optimization
//
// When deleting all rows (no WHERE clause), the compiler can use the truncate
// optimization which is much faster:
//
//	stmt := NewDeleteStmt("users", nil) // No WHERE = delete all
//	prog, err := CompileDeleteWithTruncateOptimization(stmt, tableRoot)
//
// # Advanced Features
//
// The package supports several advanced SQLite features:
//
//   - Auto-increment columns
//   - Foreign key constraints (with CompileDeleteWithForeignKeys)
//   - Index maintenance (with CompileUpdateWithIndex, CompileDeleteWithIndex)
//   - Conflict resolution (OR REPLACE, OR IGNORE, etc.)
//
// # Performance Considerations
//
// - Records are encoded using varints for space efficiency
// - Integer values from -128 to 127 are stored in 1 byte
// - Constants 0 and 1 require no storage (serial types 8 and 9)
// - Text and blobs are stored inline with length encoded in serial type
//
// # Thread Safety
//
// This package's types are not thread-safe. Compilation should be performed
// in a single goroutine. The resulting Program can be shared read-only across
// goroutines, but execution requires proper synchronization.
//
// # References
//
// This implementation is based on the SQLite C source code:
//   - insert.c: INSERT statement processing
//   - update.c: UPDATE statement processing
//   - delete.c: DELETE statement processing
//   - vdbeaux.c: Record format and serial types
//
// SQLite documentation:
//   - https://www.sqlite.org/fileformat.html
//   - https://www.sqlite.org/opcode.html
package sql
